devtools::build()
devtools::document()
library(seer)
devtools::document()
devtools::document()
dmax <- 6 # max model size (Sam stops at models with 10 predictors)
seed = 666
sample.int(1e6,dmax)
devtools::document()
library(seer)
x_train = matrix(rnorm(100*100),100,100)
y_train = rnorm(100)
require(caret)
require(doParallel)
## Meta parameters
q0 <- .05 # quantile for screening
dmax <- 6 # max model size (Sam stops at models with 10 predictors)
mod_max <- 4e4 # model explored at each step
## simu data
y_train = rnorm(100)
xx_train = matrix(rnorm(100*20),100,20)
require(caret)
require(doParallel)
## Meta parameters
q0 <- .05 # quantile for screening
dmax <- 6 # max model size (Sam stops at models with 10 predictors)
mod_max <- 4e4 # model explored at each step
## simu data
y_train = rnorm(100)
x_train = matrix(rnorm(100*20),100,20)
# Initial step: (dimension 1)
# EXAMPLE FOR D=1
cv_errors <- vector("numeric",ncol(x_train))
nc = detectCores()
cl <- makeCluster(cl)
registerDoParallel(cl)
start_time <- Sys.time()
start_time_1 <- Sys.time()
trctrl <- trainControl(method = "repeatedcv", number = 10, repeats = 10) #10 fold CV repeated 10 times as PANNING
cv_errors <- foreach(i = seq_along(cv_errors), .combine = c, .packages=c("caret")) %dopar% {
seed <- graine[1] + i
X <- as.matrix(x_train[,i])
y <- as.factor(y_train)
breast_1 = data.frame(y,X)
obj = train(y ~., data = breast_1, method = "svmLinear", trControl=trctrl, preProcess = c("center", "scale"),tuneLength = 10)
cv_errors = 1 - max(obj$results$Accuracy)
}
stopCluster(cl)
end_time_1 <- Sys.time()
end_time_1 - start_time_1
require(caret)
require(doParallel)
## Meta parameters
q0 <- .05 # quantile for screening
dmax <- 6 # max model size (Sam stops at models with 10 predictors)
mod_max <- 4e4 # model explored at each step
## simu data
y_train = rnorm(100)
x_train = matrix(rnorm(100*20),100,20)
#### for each computing time
# Initial step: (dimension 1)
# EXAMPLE FOR D=1
cv_errors <- vector("numeric",ncol(x_train))
nc = detectCores()
cl <- makeCluster(cl)
registerDoParallel(cl)
start_time <- Sys.time()
start_time_1 <- Sys.time()
trctrl <- trainControl(method = "repeatedcv", number = 10, repeats = 10) #10 fold CV repeated 10 times as PANNING
cv_errors <- foreach(i = seq_along(cv_errors), .combine = c, .packages=c("caret")) %dopar% {
X <- as.matrix(x_train[,i])
y <- as.factor(y_train)
breast_1 = data.frame(y,X)
obj = train(y ~., data = breast_1, method = "svmLinear", trControl=trctrl, preProcess = c("center", "scale"),tuneLength = 10)
cv_errors = 1 - max(obj$results$Accuracy)
}
cv_errors
seq_along(cv_errors)
seq_len(cv_errors)
seq_along(cv_errors)
seq_len(cv_errors)
number = 10, repeats = 10) #10 fold CV repeated 10 times as PANNING
cv_errors <- foreach(
1
)
i = seq_along(cv_errors)
i
ncol(x_train)
require(caret)
require(doParallel)
## Meta parameters
q0 <- .05 # quantile for screening
dmax <- 6 # max model size (Sam stops at models with 10 predictors)
mod_max <- 4e4 # model explored at each step
## simu data
y_train = rnorm(100)
x_train = matrix(rnorm(100*2),100,2)
#### for each computing time
# Initial step: (dimension 1)
# EXAMPLE FOR D=1
cv_errors <- vector("numeric",ncol(x_train))
nc = detectCores()
cl <- makeCluster(cl)
registerDoParallel(cl)
start_time <- Sys.time()
start_time_1 <- Sys.time()
trctrl <- trainControl(method = "repeatedcv", number = 10, repeats = 10) #10 fold CV repeated 10 times as PANNING
cv_errors <- foreach(i = seq_along(cv_errors), .combine = c, .packages=c("caret")) %dopar% {
X <- as.matrix(x_train[,i])
y <- as.factor(y_train)
breast_1 = data.frame(y,X)
obj = train(y ~., data = breast_1, method = "svmLinear", trControl=trctrl, preProcess = c("center", "scale"),tuneLength = 10)
cv_errors = 1 - max(obj$results$Accuracy)
}
stopCluster(cl)
end_time_1 <- Sys.time()
end_time_1 - start_time_1
cv_errors <- vector("numeric",ncol(x_train))
nc = detectCores()
cl <- makePSOCKcluster(nc)
registerDoParallel(cl)
start_time2 <- Sys.time()
trctrl <- trainControl(method = "repeatedcv", number = 10, repeats = 10) #10 fold CV repeated 10 times as PANNING
for(i in seq_along(cv_errors)){
seed <- graine[1] + i
X <- as.matrix(x_train[,i])
y <- as.factor(y_train)
breast_1 = data.frame(y,X)
obj = train(y ~., data = breast_1, method = "svmLinear", trControl=trctrl, preProcess = c("center", "scale"),tuneLength = 10)
cv_errors[i] = 1 - max(obj$results$Accuracy)
}
stopCluster(cl)
end_time2 <- Sys.time()
end_time2 - start_time2
cv_errors <- vector("numeric",ncol(x_train))
nc = detectCores()
cl <- makePSOCKcluster(nc)
registerDoParallel(cl)
start_time2 <- Sys.time()
trctrl <- trainControl(method = "repeatedcv", number = 10, repeats = 10) #10 fold CV repeated 10 times as PANNING
for(i in seq_along(cv_errors)){
X <- as.matrix(x_train[,i])
y <- as.factor(y_train)
breast_1 = data.frame(y,X)
obj = train(y ~., data = breast_1, method = "svmLinear", trControl=trctrl, preProcess = c("center", "scale"),tuneLength = 10)
cv_errors[i] = 1 - max(obj$results$Accuracy)
}
stopCluster(cl)
end_time2 <- Sys.time()
end_time2 - start_time2
?stop
learner = "tamer"
obj = train(y ~., data = df, method = learner, trControl=trctrl, preProcess = c("center", "scale"),tuneLength = 10)
seq_along(cv_errors)
devtools::document()
library(seer)
library(dplyr)
library(Hmisc)
library(igraph)
library(RColorBrewer)
library(stringr)
setwd("/Users/gaetan/GitHub/breast-cancer/Graph/mean covariate")
load("relation_mat.rda")
load("col_mat.rda")
load("gene_network_data.rda")
load("med_beta.rda")
MAX_EDGE_WIDTH = 10
############################################################################################################################################
###################################################### FULL NETWORK ########################################################################
############################################################################################################################################
## Remove ebv
iebv2 = which(relation_mat[,2] == "ebv-miR-BART6-3p")
iebv1 = which(relation_mat[,1] == "ebv-miR-BART6-3p")
rm_iebv = c(iebv1,iebv2)
relation_mat = relation_mat[-rm_iebv,]
# Color of edges
index = rep(NA,nrow(relation_mat))
for(i in 1:nrow(relation_mat)){
i1 = which(relation_mat[i,1] == mat_col[,1] & relation_mat[i,2] == mat_col[,2])
i2 = which(relation_mat[i,1] == mat_col[,2] & relation_mat[i,2] == mat_col[,1])
if(length(c(i1,i2))==0){
index[i] = NA
}else{
index[i] = c(i1,i2)
}
}
## remove ebv
gene_network_data = gene_network_data[-16,]
# Color of vrtex based on median
index_med = rep(NA,nrow(gene_network_data))
for(i in 1:nrow(gene_network_data)){
if( length(which(gene_network_data[i,1] == med_beta[,1])) == 0){
index_med[i] = NA
}else{
index_med[i] = which(gene_network_data[i,1] == med_beta[,1])
}
}
relation_mat = data.frame(relation_mat,directed = F)
col_edge = mat_col[index,3]
col_edge[is.na(col_edge)] = "#F0F8FF"
## Duplicate relation mat
relation_mat_dup = relation_mat
# Remove hsa-mir from name
relation_mat_dup[,1] = gsub(".*R-", "", relation_mat[,1])
relation_mat_dup[,2] = gsub(".*R-", "", relation_mat[,2])
gene_network_data = data.frame(gene_network_data)
col_vertex = as.vector(med_beta$col_med_beta[index_med])
library(tikzDevice)
tikz("tex/network.tex", width = 8, height = 5, standAlone = TRUE,
packages = c("\\usepackage{tikz}",
"\\usepackage[active,tightpage,psfixbb]{preview}",
"\\PreviewEnvironment{pgfpicture}",
"\\setlength\\PreviewBorder{0pt}",
"\\usepackage{amssymb}",
"\\usepackage{bm}","\\usepackage{amsthm}","\\usepackage{amsbsy}"
,"\\usepackage{amsbsy}"
,"\\usepackage{amsbsy}"
,"\\usepackage{amsfonts}"))
### Create graph
g = graph.data.frame(relation_mat_dup, directed=F)
vertex_size = 40
par(mfrow = c(1,1),mar = c(0,0,0,0), oma = c(0,0,0,0))
# layout
l = layout_with_fr(g)
l = norm_coords(l)
V(g)$x = l[,1]
V(g)$y = l[,2]
V(g)$color = col_vertex
V(g)$shape = "circle"
V(g)$label = V(g)$name
V(g)$label.color = "black"
V(g)$label.font = 2
V(g)$label.family = "sans"
V(g)$label.cex = 0.7
V(g)$label.degree = pi/2
V(g)$size = (gene_network_data$percentage/max(gene_network_data$percentage))*vertex_size
# duplicate lines
edge_width = (relation_mat$rel_strenght)*20
edge_width[edge_width > MAX_EDGE_WIDTH] = MAX_EDGE_WIDTH
E(g)$color = col_edge
E(g)$width = edge_width
E(g)$curved = .2
E(g)$arrow.size = .5
plot(g)
#############
dev.off()
############################################################################################################################################
###################################################### NETWORK 140-3P ######################################################################
############################################################################################################################################
gene = "140-3p"
i1 = which(relation_mat_dup[,1] == gene)
i2 = which(relation_mat_dup[,2] == gene)
single_gene = relation_mat[c(i1,i2),]
nrow(single_gene)
nrow(gene_network_data)
single_gene_mat = relation_mat_dup[c(i1,i2),]
col_edge = col_edge[c(i1,i2)]
### Create graph
g = graph.data.frame(single_gene_mat, directed=F)
vertex_size = 40
par(mfrow = c(1,1),mar = c(0,0,0,0), oma = c(0,0,0,0))
# layout
l = layout_with_fr(g)
l = norm_coords(l)
V(g)$x = l[,1]
V(g)$y = l[,2]
V(g)$color = col_vertex
V(g)$shape = "circle"
V(g)$label = V(g)$name
V(g)$label.color = "black"
V(g)$label.font = 2
V(g)$label.family = "sans"
V(g)$label.cex = 0.7
V(g)$label.degree = pi/2
V(g)$size = (gene_network_data$percentage/max(gene_network_data$percentage))*vertex_size
# duplicate lines
edge_width = (single_gene$rel_strenght)*100
edge_width[edge_width > MAX_EDGE_WIDTH] = MAX_EDGE_WIDTH
E(g)$color = col_edge
E(g)$width = edge_width
E(g)$curved = .2
E(g)$arrow.size = .5
plot(g)
#############
ts = as.numeric(Sys.time())
out_fname = sprintf("./tex/network_140-3p_%.0f", ts)
png(str_c(out_fname, ".png"), width = 9, height = 9, units = "in", res = 300)
plot(g, rescale = F)
dev.off()
############################################################################################################################################
###################################################### NETWORK 140-3P ######################################################################
############################################################################################################################################
gene = "375"
i1 = which(relation_mat_dup[,1] == gene)
i2 = which(relation_mat_dup[,2] == gene)
single_gene = relation_mat[c(i1,i2),]
nrow(single_gene)
nrow(gene_network_data)
single_gene_mat = relation_mat_dup[c(i1,i2),]
col_edge = col_edge[c(i1,i2)]
### Create graph
g = graph.data.frame(single_gene_mat, directed=F)
vertex_size = 40
par(mfrow = c(1,1),mar = c(0,0,0,0), oma = c(0,0,0,0))
# layout
l = layout_with_fr(g)
l = norm_coords(l)
V(g)$x = l[,1]
V(g)$y = l[,2]
V(g)$color = col_vertex
V(g)$shape = "circle"
V(g)$label = V(g)$name
V(g)$label.color = "black"
V(g)$label.font = 2
V(g)$label.family = "sans"
V(g)$label.cex = 0.7
V(g)$label.degree = pi/2
V(g)$size = (gene_network_data$percentage/max(gene_network_data$percentage))*vertex_size
# duplicate lines
edge_width = (single_gene$rel_strenght)*100
edge_width[edge_width > MAX_EDGE_WIDTH] = MAX_EDGE_WIDTH
E(g)$color = col_edge
E(g)$width = edge_width
E(g)$curved = .2
E(g)$arrow.size = .5
plot(g)
